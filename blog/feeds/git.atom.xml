<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>kmolsite</title><link href="http://chiamingyen.github.io/kmolsite/blog/" rel="alternate"></link><link href="http://chiamingyen.github.io/kmolsite/blog/feeds/git.atom.xml" rel="self"></link><id>http://chiamingyen.github.io/kmolsite/blog/</id><updated>2016-01-05T22:19:54+08:00</updated><entry><title>git cheat sheet</title><link href="http://chiamingyen.github.io/kmolsite/blog/git-cheat-sheet.html" rel="alternate"></link><updated>2016-01-05T22:19:54+08:00</updated><author><name>kmol</name></author><id>tag:chiamingyen.github.io,2016-01-05:kmolsite/blog/git-cheat-sheet.html</id><summary type="html">&lt;p&gt;git 常用指令回顧&lt;/p&gt;


&lt;p&gt;以下為常用的 git 指令:&lt;/p&gt;
&lt;p&gt;Setup&lt;/p&gt;
&lt;p&gt;Show current configuration:&lt;/p&gt;
&lt;p&gt;$ git config --list&lt;/p&gt;
&lt;p&gt;Show local configuration:&lt;/p&gt;
&lt;p&gt;$ git config --local --list&lt;/p&gt;
&lt;p&gt;Show global configuration:&lt;/p&gt;
&lt;p&gt;$ git config --global --list&lt;/p&gt;
&lt;p&gt;Show system configuration:&lt;/p&gt;
&lt;p&gt;$ git config --system --list&lt;/p&gt;
&lt;p&gt;Set a name that is identifiable for credit when review version history:&lt;/p&gt;
&lt;p&gt;$ git config --global user.name “[firstname lastname]”&lt;/p&gt;
&lt;p&gt;Set an email address that will be associated with each history marker:&lt;/p&gt;
&lt;p&gt;$ git config --global user.email “[valid-email]”&lt;/p&gt;
&lt;p&gt;Set automatic command line coloring for Git for easy reviewing:&lt;/p&gt;
&lt;p&gt;$ git config --global color.ui auto&lt;/p&gt;
&lt;p&gt;Configuration Files&lt;/p&gt;
&lt;p&gt;Repository specific configuration file [--local]:&lt;/p&gt;
&lt;p&gt;&lt;repo&gt;/.git/config&lt;/p&gt;
&lt;p&gt;User-specific configuration file [--global]:&lt;/p&gt;
&lt;p&gt;~/.gitconfig&lt;/p&gt;
&lt;p&gt;System-wide configuration file [--system]:&lt;/p&gt;
&lt;p&gt;/etc/gitconfig&lt;/p&gt;
&lt;p&gt;Create&lt;/p&gt;
&lt;p&gt;Clone an existing repository:&lt;/p&gt;
&lt;p&gt;There are two ways:&lt;/p&gt;
&lt;p&gt;Via SSH&lt;/p&gt;
&lt;p&gt;$ git clone ssh://user@domain.com/repo.git&lt;/p&gt;
&lt;p&gt;Via HTTP&lt;/p&gt;
&lt;p&gt;$ git clone http://domain.com/user/repo.git&lt;/p&gt;
&lt;p&gt;Create a new local repository:&lt;/p&gt;
&lt;p&gt;$ git init&lt;/p&gt;
&lt;p&gt;Local Changes&lt;/p&gt;
&lt;p&gt;Changes in working directory:&lt;/p&gt;
&lt;p&gt;$ git status&lt;/p&gt;
&lt;p&gt;Changes to tracked files:&lt;/p&gt;
&lt;p&gt;$ git diff&lt;/p&gt;
&lt;p&gt;Add all current changes to the next commit:&lt;/p&gt;
&lt;p&gt;$ git add&lt;/p&gt;
&lt;p&gt;Add some changes in &lt;file&gt; to the next commit:&lt;/p&gt;
&lt;p&gt;$ git add -p &lt;file&gt;&lt;/p&gt;
&lt;p&gt;Commit all local changes in tracked files:&lt;/p&gt;
&lt;p&gt;$ git commit -a&lt;/p&gt;
&lt;p&gt;Commit previously staged changes:&lt;/p&gt;
&lt;p&gt;$ git commit&lt;/p&gt;
&lt;p&gt;Commit with message:&lt;/p&gt;
&lt;p&gt;$ git commit -m 'message here'&lt;/p&gt;
&lt;p&gt;Commit skipping the staging area and adding message:&lt;/p&gt;
&lt;p&gt;$ git commit -am 'message here'&lt;/p&gt;
&lt;p&gt;Commit to some previous date:&lt;/p&gt;
&lt;p&gt;git commit --date="&lt;code&gt;date --date='n day ago'&lt;/code&gt;" -am "Commit Message"&lt;/p&gt;
&lt;p&gt;Change last commit:&lt;/p&gt;
&lt;p&gt;Don't amend published commits!&lt;/p&gt;
&lt;p&gt;$ git commit -a --amend&lt;/p&gt;
&lt;p&gt;Move uncommitted changes from current branch to some other branch:&lt;/p&gt;
&lt;p&gt;git stash
git checkout branch2
git stash pop&lt;/p&gt;
&lt;p&gt;Restore stashed changes back to current branch&lt;/p&gt;
&lt;p&gt;git stash apply&lt;/p&gt;
&lt;p&gt;Search&lt;/p&gt;
&lt;p&gt;A text search on all files in the directory:&lt;/p&gt;
&lt;p&gt;$ git grep "Hello"&lt;/p&gt;
&lt;p&gt;In any version of a text search:&lt;/p&gt;
&lt;p&gt;$ git grep "Hello" v2.5&lt;/p&gt;
&lt;p&gt;Commit History&lt;/p&gt;
&lt;p&gt;Show all commits, starting with newest (it'll show the hash, author information, date of commit and title of the commit):&lt;/p&gt;
&lt;p&gt;$ git log&lt;/p&gt;
&lt;p&gt;Show all the commits(it'll show just the commit hash and the commit message):&lt;/p&gt;
&lt;p&gt;$ git log --oneline&lt;/p&gt;
&lt;p&gt;Show all commits of a specific user:&lt;/p&gt;
&lt;p&gt;$ git log --author="username"&lt;/p&gt;
&lt;p&gt;Show changes over time for a specific file:&lt;/p&gt;
&lt;p&gt;$ git log -p &lt;file&gt;&lt;/p&gt;
&lt;p&gt;Who changed, what and when in &lt;file&gt;:&lt;/p&gt;
&lt;p&gt;$ git blame &lt;file&gt;&lt;/p&gt;
&lt;p&gt;Branches &amp;amp; Tags&lt;/p&gt;
&lt;p&gt;List all local branches:&lt;/p&gt;
&lt;p&gt;$ git branch&lt;/p&gt;
&lt;p&gt;List all remote branches:&lt;/p&gt;
&lt;p&gt;$ git branch -r&lt;/p&gt;
&lt;p&gt;Switch HEAD branch:&lt;/p&gt;
&lt;p&gt;$ git checkout &lt;branch&gt;&lt;/p&gt;
&lt;p&gt;Create and switch new branch:&lt;/p&gt;
&lt;p&gt;$ git checkout -b &lt;branch&gt;&lt;/p&gt;
&lt;p&gt;Create a new branch based on your current HEAD:&lt;/p&gt;
&lt;p&gt;$ git branch &lt;new-branch&gt;&lt;/p&gt;
&lt;p&gt;Create a new tracking branch based on a remote branch:&lt;/p&gt;
&lt;p&gt;$ git branch --track &lt;new-branch&gt; &lt;remote-branch&gt;&lt;/p&gt;
&lt;p&gt;Delete a local branch:&lt;/p&gt;
&lt;p&gt;$ git branch -d &lt;branch&gt;&lt;/p&gt;
&lt;p&gt;Force delete a local branch:&lt;/p&gt;
&lt;p&gt;You will lose unmerged changes!&lt;/p&gt;
&lt;p&gt;$ git branch -D &lt;branch&gt;&lt;/p&gt;
&lt;p&gt;Mark the current commit with a tag:&lt;/p&gt;
&lt;p&gt;$ git tag &lt;tag-name&gt;&lt;/p&gt;
&lt;p&gt;Mark the current commit with a tag that includes a message:&lt;/p&gt;
&lt;p&gt;$ git tag -a &lt;tag-name&gt;&lt;/p&gt;
&lt;p&gt;Update &amp;amp; Publish&lt;/p&gt;
&lt;p&gt;List all current configured remotes:&lt;/p&gt;
&lt;p&gt;$ git remote -v&lt;/p&gt;
&lt;p&gt;Show information about a remote:&lt;/p&gt;
&lt;p&gt;$ git remote show &lt;remote&gt;&lt;/p&gt;
&lt;p&gt;Add new remote repository, named &lt;remote&gt;:&lt;/p&gt;
&lt;p&gt;$ git remote add &lt;remote&gt; &lt;url&gt;&lt;/p&gt;
&lt;p&gt;Download all changes from &lt;remote&gt;, but don't integrate into HEAD:&lt;/p&gt;
&lt;p&gt;$ git fetch &lt;remote&gt;&lt;/p&gt;
&lt;p&gt;Download changes and directly merge/integrate into HEAD:&lt;/p&gt;
&lt;p&gt;$ git remote pull &lt;remote&gt; &lt;url&gt;&lt;/p&gt;
&lt;p&gt;Get all changes from HEAD to local repository:&lt;/p&gt;
&lt;p&gt;$ git pull origin master&lt;/p&gt;
&lt;p&gt;Get all changes from HEAD to local repository without a merge:&lt;/p&gt;
&lt;p&gt;git pull --rebase &lt;remote&gt; &lt;branch&gt;&lt;/p&gt;
&lt;p&gt;Publish local changes on a remote:&lt;/p&gt;
&lt;p&gt;$ git push remote &lt;remote&gt; &lt;branch&gt;&lt;/p&gt;
&lt;p&gt;Delete a branch on the remote:&lt;/p&gt;
&lt;p&gt;$ git push &lt;remote&gt; :&lt;branch&gt; (since Git v1.5.0)
or
git push &lt;remote&gt; --delete &lt;branch&gt; (since Git v1.7.0)&lt;/p&gt;
&lt;p&gt;Publish your tags:&lt;/p&gt;
&lt;p&gt;$ git push --tags&lt;/p&gt;
&lt;p&gt;Merge &amp;amp; Rebase&lt;/p&gt;
&lt;p&gt;Merge into your current HEAD:&lt;/p&gt;
&lt;p&gt;$ git merge &lt;branch&gt;&lt;/p&gt;
&lt;p&gt;Rebase your current HEAD onto &lt;branch&gt;:&lt;/p&gt;
&lt;p&gt;Don't rebase published commit!&lt;/p&gt;
&lt;p&gt;$ git rebase &lt;branch&gt;&lt;/p&gt;
&lt;p&gt;Abort a rebase:&lt;/p&gt;
&lt;p&gt;$ git rebase --abort&lt;/p&gt;
&lt;p&gt;Continue a rebase after resolving conflicts:&lt;/p&gt;
&lt;p&gt;$ git rebase --continue&lt;/p&gt;
&lt;p&gt;Use your configured merge tool to solve conflicts:&lt;/p&gt;
&lt;p&gt;$ git mergetool&lt;/p&gt;
&lt;p&gt;Use your editor to manually solve conflicts and (after resolving) mark file as resolved:&lt;/p&gt;
&lt;p&gt;$ git add &lt;resolved-file&gt;
$ git rm &lt;resolved-file&gt;&lt;/p&gt;
&lt;p&gt;Squashing commits:&lt;/p&gt;
&lt;p&gt;$ git rebase -i &lt;commit-just-before-first&gt;&lt;/p&gt;
&lt;p&gt;Now replace this,&lt;/p&gt;
&lt;p&gt;pick &lt;commit_id&gt;
pick &lt;commit_id2&gt;
pick &lt;commit_id3&gt;
to this,&lt;/p&gt;
&lt;p&gt;pick &lt;commit_id&gt;
squash &lt;commit_id2&gt;
squash &lt;commit_id3&gt;
Undo&lt;/p&gt;
&lt;p&gt;Discard all local changes in your working directory:&lt;/p&gt;
&lt;p&gt;$ git reset --hard HEAD&lt;/p&gt;
&lt;p&gt;Get all the files out of the staging area(i.e. undo the last git add):&lt;/p&gt;
&lt;p&gt;$ git reset HEAD&lt;/p&gt;
&lt;p&gt;Discard local changes in a specific file:&lt;/p&gt;
&lt;p&gt;$ git checkout HEAD &lt;file&gt;&lt;/p&gt;
&lt;p&gt;Revert a commit (by producing a new commit with contrary changes):&lt;/p&gt;
&lt;p&gt;$ git revert &lt;commit&gt;&lt;/p&gt;
&lt;p&gt;Reset your HEAD pointer to a previous commit and discard all changes since then:&lt;/p&gt;
&lt;p&gt;$ git reset --hard &lt;commit&gt;&lt;/p&gt;
&lt;p&gt;Reset your HEAD pointer to a remote branch current state.&lt;/p&gt;
&lt;p&gt;git reset --hard &lt;remote/branch&gt; e.g., upstream/master, origin/my-feature
Reset your HEAD pointer to a previous commit and preserve all changes as unstaged changes:&lt;/p&gt;
&lt;p&gt;$ git reset &lt;commit&gt;&lt;/p&gt;
&lt;p&gt;Reset your HEAD pointer to a previous commit and preserve uncommitted local changes:&lt;/p&gt;
&lt;p&gt;$ git reset --keep &lt;commit&gt;&lt;/p&gt;
&lt;p&gt;Remove files that were accidentally committed before they were added to .gitignore&lt;/p&gt;
&lt;p&gt;$ git rm -r --cached .
$ git add .
$ git commit -m "remove xyz file"&lt;/p&gt;
&lt;p&gt;Git-Flow&lt;/p&gt;
&lt;p&gt;You need a working git installation as prerequisite. Git flow works on OSX, Linux and Windows.&lt;/p&gt;
&lt;p&gt;OSX Homebrew:&lt;/p&gt;
&lt;p&gt;$ brew install git-flow&lt;/p&gt;
&lt;p&gt;OSX Macports:&lt;/p&gt;
&lt;p&gt;$ port install git-flow&lt;/p&gt;
&lt;p&gt;Linux (Debian-based):&lt;/p&gt;
&lt;p&gt;$ apt-get install git-flow&lt;/p&gt;
&lt;p&gt;Windows (Cygwin):&lt;/p&gt;
&lt;p&gt;You need wget and util-linux to install git-flow.&lt;/p&gt;
&lt;p&gt;$ wget -q -O - --no-check-certificate https://github.com/nvie/gitflow/raw/develop/contrib/gitflow-installer.sh | bash&lt;/p&gt;
&lt;p&gt;Getting Started&lt;/p&gt;
&lt;p&gt;Git flow needs to be initialized in order to customize your project setup. Start using git-flow by initializing it inside an existing git repository:&lt;/p&gt;
&lt;p&gt;Initialize:&lt;/p&gt;
&lt;p&gt;You'll have to answer a few questions regarding the naming conventions for your branches. It's recommended to use the default values.&lt;/p&gt;
&lt;p&gt;git flow init&lt;/p&gt;
&lt;p&gt;Features&lt;/p&gt;
&lt;p&gt;Develop new features for upcoming releases. Typically exist in developers repos only.&lt;/p&gt;
&lt;p&gt;Start a new feature:&lt;/p&gt;
&lt;p&gt;This action creates a new feature branch based on 'develop' and switches to it.&lt;/p&gt;
&lt;p&gt;git flow feature start MYFEATURE&lt;/p&gt;
&lt;p&gt;Finish up a feature:&lt;/p&gt;
&lt;p&gt;Finish the development of a feature. This action performs the following:&lt;/p&gt;
&lt;p&gt;1)Merged MYFEATURE into 'develop'.&lt;/p&gt;
&lt;p&gt;2)Removes the feature branch.&lt;/p&gt;
&lt;p&gt;3)Switches back to 'develop' branch&lt;/p&gt;
&lt;p&gt;git flow feature finish MYFEATURE
Publish a feature:&lt;/p&gt;
&lt;p&gt;Are you developing a feature in collaboration? Publish a feature to the remote server so it can be used by other users.&lt;/p&gt;
&lt;p&gt;git flow feature publish MYFEATURE&lt;/p&gt;
&lt;p&gt;Getting a published feature:&lt;/p&gt;
&lt;p&gt;Get a feature published by another user.&lt;/p&gt;
&lt;p&gt;git flow feature pull origin MYFEATURE&lt;/p&gt;
&lt;p&gt;Tracking a origin feature:&lt;/p&gt;
&lt;p&gt;You can track a feature on origin by using&lt;/p&gt;
&lt;p&gt;git flow feature track MYFEATURE&lt;/p&gt;
&lt;p&gt;Make a Release&lt;/p&gt;
&lt;p&gt;Support preparation of a new production release. Allow for minor bug fixes and preparing meta-data for a release&lt;/p&gt;
&lt;p&gt;Start a release:&lt;/p&gt;
&lt;p&gt;To start a release, use the git flow release command. It creates a release branch created from the 'develop' branch. You can optionally supply a [BASE] commit sha-1 hash to start the release from. The commit must be on the 'develop' branch.&lt;/p&gt;
&lt;p&gt;git flow release start RELEASE [BASE]&lt;/p&gt;
&lt;p&gt;It's wise to publish the release branch after creating it to allow release commits by other developers. Do it similar to feature publishing with the command:&lt;/p&gt;
&lt;p&gt;git flow release publish RELEASE&lt;/p&gt;
&lt;p&gt;(You can track a remote release with the: git flow release track RELEASE command)&lt;/p&gt;
&lt;p&gt;Finish up a release:&lt;/p&gt;
&lt;p&gt;Finishing a release is one of the big steps in git branching. It performs several actions:&lt;/p&gt;
&lt;p&gt;1)Merges the release branch back into 'master'&lt;/p&gt;
&lt;p&gt;2)Tags the release with its name&lt;/p&gt;
&lt;p&gt;3)Back-merges the release into 'develop'&lt;/p&gt;
&lt;p&gt;4)Removes the release branch&lt;/p&gt;
&lt;p&gt;git flow release finish RELEASE&lt;/p&gt;
&lt;p&gt;Don't forget to push your tags with git push --tags&lt;/p&gt;
&lt;p&gt;Hotfixes&lt;/p&gt;
&lt;p&gt;Hotfixes arise from the necessity to act immediately upon an undesired state of a live production version. May be branched off from the corresponding tag on the master branch that marks the production version.&lt;/p&gt;
&lt;p&gt;Git flow hotfix start:&lt;/p&gt;
&lt;p&gt;Like the other git flow commands, a hotfix is started with&lt;/p&gt;
&lt;p&gt;$ git flow hotfix start VERSION [BASENAME]&lt;/p&gt;
&lt;p&gt;The version argument hereby marks the new hotfix release name. Optionally you can specify a basename to start from.&lt;/p&gt;
&lt;p&gt;Finish a hotfix:&lt;/p&gt;
&lt;p&gt;By finishing a hotfix it gets merged back into develop and master. Additionally the master merge is tagged with the hotfix version&lt;/p&gt;
&lt;p&gt;git flow hotfix finish VERSION&lt;/p&gt;</summary><category term="Git"></category></entry><entry><title>Remove local and remote branch</title><link href="http://chiamingyen.github.io/kmolsite/blog/remove-local-and-remote-branch.html" rel="alternate"></link><updated>2015-12-16T15:33:24+08:00</updated><author><name>kmol</name></author><id>tag:chiamingyen.github.io,2015-12-16:kmolsite/blog/remove-local-and-remote-branch.html</id><summary type="html">&lt;p&gt;刪除近端與遠端的 Git 分支.&lt;/p&gt;


&lt;p&gt;To delete a local branch&lt;/p&gt;
&lt;p&gt;git branch -D the_local_branch&lt;/p&gt;
&lt;p&gt;To remove a remote branch&lt;/p&gt;
&lt;p&gt;git push origin :the_remote_branch&lt;/p&gt;
&lt;p&gt;or &lt;/p&gt;
&lt;p&gt;git push origin --delete the_remote_branch&lt;/p&gt;</summary><category term="Git 指令"></category></entry></feed>